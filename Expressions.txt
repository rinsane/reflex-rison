primary_expression
	: IDENTIFIER
	| CONSTANT
	| STRING_LITERAL
	| '(' expression ')'
	;

expression
	: assignment_expression
	| expression ',' assignment_expression
	;

assignment_expression
	: conditional_expression # left because very very tedious!
	| unary_expression assignment_operator assignment_expression
	;

unary_expression
	: postfix_expression
	| "++" unary_expression
	| "--" unary_expression
	| unary_operator cast_expression
	| "SIZEOF" unary_expression
	| "SIZEOF" '(' type_name ')'
	;

cast_expression
	: unary_expression
	| '(' type_name ')' cast_expression
	;

type_name
	: specifier_qualifier_list
	| specifier_qualifier_list abstract_declarator # pointers not done!
	;

unary_operator
	: '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	;

assignment_operator
	: '='
	| "*="   # MUL_ASSIGN            
	| "/="   # DIV_ASSIGN            
	| "%="   # MOD_ASSIGN            
	| "+="   # ADD_ASSIGN            
	| "-="   # SUB_ASSIGN            
	| "<<="  # LEFT_ASSIGN            
	| ">>="  # RIGHT_ASSIGN            
	| "&="   # AND_ASSIGN            
	| "^="   # XOR_ASSIGN            
	| "|="   # OR_ASSIGN            
	;

=> IDENTIFIER:
    int check_type()
    {
    /*
    * pseudo code --- this is what it should check
    *
    *	if (yytext == type_name)
    *		return(TYPE_NAME);
    *
    *	return(IDENTIFIER);
    */
    
    /*
    *	it actually will only return IDENTIFIER
    */
    
    return(IDENTIFIER);
    }

=> CONSTANT:
    0[xX]{H}+{IS}?		{ count(); return(CONSTANT); }
    0{D}+{IS}?		{ count(); return(CONSTANT); }
    {D}+{IS}?		{ count(); return(CONSTANT); }
    L?'(\\.|[^\\'])+'	{ count(); return(CONSTANT); }

    {D}+{E}{FS}?		{ count(); return(CONSTANT); }
    {D}*"."{D}+({E})?{FS}?	{ count(); return(CONSTANT); }
    {D}+"."{D}*({E})?{FS}?	{ count(); return(CONSTANT); }

=> STRING_LITERAL:
    L?\"(\\.|[^\\"])*\"	{ count(); return(STRING_LITERAL); }